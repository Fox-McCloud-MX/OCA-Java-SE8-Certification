page 135 to 153

My Answers:

1  - D [OK]
2  - B [OK]
3  - D [OK]
4  - A [OK]
5  - A [FAIL]
6  - B [OK]
7  - A [OK]
8  - A [OK]
9  - C [OK]
10 - C [OK]
11 - B [OK]
12 - A [OK]
13 - C [OK]
14 - C [OK]
15 - C [OK]
16 - B [OK]
17 - A [FAIL]
18 - D [FAIL]
19 - D [OK]
20 - C [OK]
21 - B [OK]
22 - C [FAIL]
23 - D [FAIl]
24 - D [FAIL]
25 - C [FAIL]
26 - B [OK]
27 - C [OK]
28 - D [OK]
29 - B [OK] book isn't correct
30 - D [OK]
31 - C [FAIL]
32 - A [OK]
33 - B [FAIL]
34 - C [OK]
35 - B [OK]
36 - B []
37 - C [OK]
38 - A []
39 - B []
40 - D [OK] REVIEW
41 - C [OK] REVIEW
42 - A [] REVIEW
43 - D [OK]
44 - D [OK]
45 - C [OK]
46 - D [OK]
47 - C [] REVIEW
48 - D [OK]
49 - A [OK] REVIEW
50 - B [] REVIEW

xx/xx = xx.00% [xxx]

Incorrect Answer.

Answers page 465

5. D. The application does not compile because score is defined only within the try
block. The other three places it is referenced, in the catch block, in the finally block,
and outside the try-catch-finally block at the end, are not in scope for this variable and
each does not compile. Therefore, the correct answer is Option D.

[throw t need to change to throw aioobe]
9. C. The application first enters the try block and outputs A. It then throws a
RuntimeException, but the exception is not caught by the catch block since
RuntimeException is not a subclass of ArrayIndexOutOfBoundsException (it is a
superclass). Next, the finally block is called and C is output. Finally, the
RuntimeException is thrown by the main() method and a stack trace is printed. For
these reasons, Option C is correct..

17. D. The code does not compile because the catch block uses parentheses () instead of
brackets {}, making Option D the correct answer. Note that Boat does not extend
Transport, so while the override on line j1 appears to be invalid since Exception is a
broader checked exception than CapsizedException, that code compiles without issue.
If the catch block was fixed, the code would output 4, making Option A the correct
answer.

18. B. Overridden methods cannot throw new or broader checked exceptions than the one
they inherit. Since Exception is a broader checked exception than PrintException,
Option B is not allowed and is the correct choice. Alternatively, declaring narrower or
the same checked exceptions or removing them entirely is allowed, making Options A
and C incorrect. Since Option B is correct, Option D is incorrect.

22. B. The application does not compile, so Option D is incorrect. The checked
KnightAttackingException thrown in the try block is handled by the associated catch
block. The ClassCastException is an unchecked exception, so it is not required to be
handled or declared and line q1 compiles without issue. The finally block throws a
checked CastleUnderSiegeException, which is required to be handled or declared by
the method, but is not. There is no try-catch around line q2, and the method does not
declare a compatible checked exception, only an unchecked exception. For this reason,
line q2 does not compile, and Option B is the correct answer. Lastly, line q3 compiles
without issue because the unchecked RuntimeException is not required to be handled
or declared by the call in the main() method.

23. A. If an exception matches multiple catch blocks, the first one that it encounters will
be the only one executed, making Option A correct, and Options B and C incorrect.
Option D is also incorrect. It is possible to write two consecutive catch blocks that can
catch the same exception, with the first type being a subclass of the second. In this
scenario, an exception thrown of the first type would match both catch blocks, but
only the first catch block would be executed, since it is the more specific match.

24. C. The code does not compile due to the call to compute() in the main() method. Even
though the compute() method only throws an unchecked exception, its method
declaration includes the Exception class, which is a checked exception. For this
reason, the checked exception must be handled or declared in the main() method in
which it is called. While there is a try-catch block in the main() method, it is only for
the unchecked NullPointerException. Since Exception is not a subclass of
NullPointerException, the checked Exception is not properly handled or declared and
the code does not compile, making Option C the correct answer.

25. D. A NullPointerException can be thrown if the value of list is null. Likewise, an
ArrayIndexOutOfBoundsException can be thrown if the value of list is an array with
fewer than 10 elements. Finally, a ClassCastException can be thrown if list is
assigned an object that is not of type Boolean[]. For example, the assignment list =
(Boolean[]) new Object() will compile without issue but throws a
ClassCastException at runtime. Therefore, the first three options are possible, making
Option D the correct answer.

[try statement requires one or more catch block]
29. A. A try statement is not required to have a finally block, but if it does, there can be
at most one. Furthermore, a try statement can have any number of catch blocks or
none at all. For these reasons, Option A is the correct answer.

31. B. If both the catch and finally blocks throw an exception, the one from the finally
block is propagated to the caller, with the one from the catch block being dropped,
making Option B the correct answer. Note that Option C is incorrect due to the fact
that only one exception can be thrown to the caller.

33. A. Although this code uses the RuntimeException and Exception classes, the question
is about casting. Exception is not a subclass of RuntimeException, so the assignment
on the second line throws a ClassCastException at runtime, making Option A correct.

35. B. If both values are valid non-null String objects, then no exception will be thrown,
with the statement in the finally block being executed first, before returning control
to the main() method; therefore, the second statement is a possible output. If either
value is null, then the toString() method will cause a NullPointerException to be
thrown. In both cases, the finally block will execute first, printing Posted:, even if
there is an exception. For this reason, the first statement is not a possible output, and
Option B is correct.

36. A. ClassCastException is a subclass of RuntimeException, so it must appear first in any
related catch blocks. If RuntimeException was to appear before ClassCastException,
then the ClassCastException block would be considered unreachable code, since any
thrown ClassCastException is already handled by the RuntimeException catch block.
For this reason, Option A is correct.

38. C. The code does not compile due to an invalid override of the operate() method. An
overridden method must not throw any new or broader checked exceptions than the
method it inherits. Even though RuntimeException is a subclass of Exception,
Exception is considered a new checked exception, since RuntimeException is an
unchecked exception. Therefore, the code does not compile, and Option C is correct.

39. D. A NullPointerException is an unchecked exception. While it can be handled by the
surrounding method, either through a try-catch block or included in the method
declaration, these are optional. For this reason, Option D is correct.

40. D. In this application, the throw RuntimeException(String) statement in the zipper()
method does not include the new keyword. The new keyword is required to create the
object being thrown, since RuntimeException(String) is a constructor. For this reason,
the code does not compile, and Option D is correct. If the keyword new was inserted
properly, then the try block would throw a CastClassException, which would be
replaced with a RuntimeException to the calling method by the catch block. The catch
block in the main() method would then be activated, and no output would be printed,
making Option C correct.

41. C. For this question, notice that all the exceptions thrown or caught are unchecked
exceptions. First, the ClassCastException is thrown in the try block and caught by the
second catch block since it inherits from RuntimeException, not
IllegalArgumentException. Next, a NullPointerException is thrown, but before it can
be returned the finally block is executed and a RuntimeException replaces it. The
application exits and the caller sees the RuntimeException in the stack trace, making
Option C the correct answer. If the finally block did not throw any exceptions, then
Option B would be the correct answer.

42. D. Trick question! Options A, B, and C are each invalid overrides of the method
because the return type must be covariant with void. For this reason, Option D is the
correct answer. If the return types were changed to be void, then Option A would be a
valid override. Options B and C would still be incorrect, since overridden methods
cannot throw broader checked exceptions than the inherited method.

47. D. The question is designed to see how closely you pay attention to throw and throws!
The try block uses the incorrect keyword, throws, to create an exception. For this
reason, the code does not compile, and Option D is correct. If throws was changed to
throw, then the code would compile without issue, and Option B would be correct.

49. C. While a catch block is permitted to include an embedded try-catch block, the issue
here is that the variable name e is already used by the first catch block. In the second
catch block, it is equivalent to declaring a variable e twice. For this reason, line z1 does
not compile, and Option C is the correct answer. If a different variable name was used
for either catch block, then the code would compile without issue, and Option A would
be the correct answer.

50. B. The finally block of the snore() method throws a new checked exception on line
x1, but there is no try-catch block around it to handle it, nor does the snore() method
declare any checked exceptions. For these reasons, line x1 does not compile, and
Option B is the correct answer. The rest of the lines of code compile without issue,
even line x3 where a static method is being accessed using an instance reference.
Note that the code inside the try block, if it ran, would produce an
ArrayIndexOutOfBoundsException, which would be caught by the RuntimeException
catch block, printing Awake!. What happens next would depend on how the finally
block was corrected.









